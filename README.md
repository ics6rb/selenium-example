# Пример тестирования ЛР9 при помощи Selenium

[Selenium](https://selenium.dev/) - это набор инструментов для [end-to-end (или e2e) тестирования](https://medium.com/the-hitchhikers-guide-to-e2e-testing/part-i-e2e-testing-and-selenium-ef031978ee20). Он используется для того, чтобы "притворяться" пользователем в каком-то определенном браузере, позволяет записать действия "пользователя" и воспроизводить их неограниченное количество раз по требованию, то есть автоматизирует процесс проверки работоспособности сайта в разных браузерах.

Необходимость такого вида тестирования обусловлена двумя основными причинами.

**Во-первых,** из-за особенностей работы браузеров, поведение (то есть внешний вид, расположение и, самое главное, "кликабельность") элементов могут различаться в разных браузерах, поэтому необходимо удостовериться в том, что в том наборе браузеров, которые поддерживает веб-приложение, все работает корректно, и пользователь вообще может, к примеру, нажать на какую-то кнопку.

**Во-вторых,** у любого приложения есть ряд глобальных сценариев (например, что пользователь может зарегистрироваться, войти, что он может оформить заказ в интернет-магазине), которые включают работу всех компонентов приложения и являются критичными для работы приложения (возвращаясь к примеру с заказом, в интернет-магазине может сломаться все, что угодно, но последней должна сломаться возможность делать там покупки). Единственный способ это проверить - полностью развернуть приложение на сервере и взаимодействовать с ним из браузера. Именно в этом может помочь Selenium.

В Selenium есть три инструмента: Selenium Webdriver, Selenium IDE и Selenium Grid.

**Selenium Webdriver** - это специальная программа, которая эмулирует конкретный браузер, и набор библиотек для разных языков программирования (сам Selenium написан на Java, но писать тесты можно не только на Java, но и на JS, Ruby, Python, ...), которые позволяют писать тесты в виде кода. Когда файл с такими тестами запускается, он обращается к Selenium, чтобы открыть окно браузера, изменить его размеры, загрузить нужную страницу, найти на ней элементы и т.д. **Чтобы запустить такие тесты, нужно установить драйвер для соответствующего браузера** (например, [для Chrome](https://sites.google.com/a/chromium.org/chromedriver/home), а также можно установить [Selenium Standalone Server](https://selenium.dev/downloads/) и подключаться к нему как к веб-приложению), потому что без него даже не откроется браузер - важно понимать, что вся логика реализована в этом драйвере и не имеет никакого отношения к, например, используемой вами библиотеке на Ruby, эта библиотека просто вызывает нужный драйвер.

**Selenium Grid** - это инструмент для параллельного запуска тестов. С помощью него можно запустить один и тот же сценарий в нескольких разных браузерах одновременно. Для того, чтобы это было возможно, специальным образом конфигурируется несколько физических или виртуальных серверов. Можно даже настроить Grid таким образов, чтобы он запускал тесты без графического интерфейса вообще - прямо в оперативной памяти сервера. Это критически важно для больших проектов, у которых много e2e тестов и которым нужно поддерживать работу своего веб-приложения в большом количестве разных браузеров, так как позволяет уменьшить время прогона тестов благодаря параллельному запуску и облегчить процесс настройки и подготовки большого количества разных тестовых окружений благодаря встроенным возможностям Selenium Grid.

**Selenium IDE** - это инструмент для быстрого прототипирования e2e-тестов прямо в браузере. Для IDE существуют расширения Chrome и Firefox. Как профессиональный инструмент Selenium IDE не подходит для работы даже со средними проектами и предоставляет весьма скудный набор возможностей. Огромным преимуществом Selenium IDE, тем не менее, является то, что **ее использование не требует никакой дополнительной настройки**, в связи с чем именно этот инструмент является наиболее предпочтительным для написания тестов по лабораторной работе 9.

## Куда смотреть

По классике: контроллер и представления. Моделей нет. Из специфических особенностей - используется AJAX через [server generated JavaScript response](https://signalvnoise.com/posts/3697-server-generated-javascript-responses).

Обратите внимание на тесты - они сделаны с помощью [RSpec](https://github.com/rspec/rspec-rails) и покрывают контроллеры, представления и маршруты.

Также можно посмотреть на настройки [Rubocop](https://github.com/rubocop-hq/rubocop) и [Reek](https://github.com/troessner/reek).

Все, что связано с Selenium, находится в директории [selenium](selenium). В ней же находится файл с более подробным описанием того, как, зачем и почему все работает.

## Установка

`bundle install`

Также не забудьте установить ChromeDriver. Тут все сильно зависит от ОС, которую вы используете, и даже от конкретного дистрибутива, поэтому конкрутных рекомендаций не будет. Но в качестве отправной точки (и решения проблем в большинстве случаев) можно использовать [эту страницу](https://github.com/SeleniumHQ/selenium/wiki/ChromeDriver).

## Запуск

Для запуска приложения используйте команду `rails s`.

Для запуска тестов - `rake spec`.

Как запускать Selenium более подробно описано в файле `selemium/README.md` этого проекта.

## Альтернативы Selenium

Selenium не спешит сдавать свои позиции, но существует ряд "наступающих на пятки" проектов, особенно в мире разработки под `node.js`. В первую очередь это связано с тем, что за все в этой жизни приходится платить, и Selenium как сложный, имеющий большое клочиество фич ресурсоемкий проект также требует
от своих пользователей вложения сил в установку, настройку и поддержку актуальной конфигурации, не говоря уже о вычислительных ресурсах. Такие жертвы могут окупиться в крупных проектах, но затормозить развитие небольших,
поэтому каждый разработчик выбирает инструмент исходя из своих нужд и доступных ему ресурсов.

Большая часть таких инструментов использует Headless Chrome, но учитывая, что [по состоянию на 2020 год](https://www.w3schools.com/browsers/) Google Chrome занимает лидирующее положение поииспользованию, это все же позволяет покрыть поведение на устройствах львиной доли пользователей (также тут нужно учитывать, что Opera и даже Edge используют движок Chromium, т.е. во многом "являются" Google Chrome с точки зрения разработчика).
Наиболее популярными среди Headless-библиотек являются:

1. [Cypress](https://www.cypress.io/how-it-works/).
2. [Protractor](https://www.protractortest.org/#/).

Огромным плюсом обеих упомянутых библиотек является то, что они позволяют писать e2e тесты практически так же, как unit-тесты.

Помимо "близких к разработке" подходов есть "близкие к бизнесу" - с использованием специальных средств [BDD](https://medium.com/@lucyhackwrench/%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-tdd-%D0%B8-bdd-%D0%BD%D0%B0-%D0%BF%D0%B0%D0%BB%D1%8C%D1%86%D0%B0%D1%85-%D0%B8-%D1%87%D1%82%D0%BE-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BE-%D0%BD%D0%B8%D1%85-%D1%84%D1%80%D0%BE%D0%BD%D1%82%D0%B5%D0%BD%D0%B4%D0%B5%D1%80-701a10e06bb9#:~:text=BDD%20(Behavior%20Driven%20Development)%20%E2%80%94,%D0%B8%D1%85%20%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8E%D1%82%D1%81%D1%8F%20%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D0%B5%20%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B.), одним из которых является [Cucumber](https://cucumber.io/). BDD как концепция заслуживает отдельного обсуждения, и цель этого репозитория не состоит в ее рассмотрении, поэтому она упоминается вскользь.
